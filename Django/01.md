# django 프로젝트 구조

## 프로젝트의 기본 구조

- costaurant

  - manage.py

  - db.sqlite

  - costaurant
  	- \_\_init__.py
  	- settings.py
  	- urls.py
  	- wsgi.py



장고 프로젝트 구조는 다음과 같다.

우선 맨 처음의 **costaurant**는 project root이다. django 프로젝트의 모든 파일이 담겨있는 최상위 디렉토리 (이름 수정해도 상관 없다)



**manage.py** 는 우리 프로젝트의 매니저다. 

- django 프로젝트 관리를 위한 명령어 지원

- 앱(app)생성, 데이터베이스 관련 명령, 개발섭 실행 등

- 거의 모든 실행을 할때 불러들이는 파일인데 둘의 기능은 거의 같다.
  ```
  python manage.py {context}
  
  or
  
  django-admin {context}
  ```

  기능적으로는 manage.py가 조금더 많다고 보면된다.

  그래서 프로젝트를 생성할 때는 `django-admin startproject {name}`으로 만들어주면 되고 나머지 명령은 `python manage.py {...}`으로 하면 된다.

  더 자세한 내용은 https://docs.djangoproject.com/en/3.2/ref/django-admin/을 참고하자.



**db.sqlite3**는 우리 프로젝트에서 사용하는 데이터 베이스 파일



다음  **costaurant**는 project app이다. 우리 프로젝트의 가장 중심이 되는 app이다. (이름바꾸면 안에 바꿔줘야할게 많으니 처음 이름 정할때 잘 만들자.)



**\_\_init__.py** 는 내가 있는 디렉토리는 하나의 python패키지로 인식하게 해주는 파일이다.
파이썬 3.3 버전 이상 부터는 이 파일이 없어도 python 패키지로 인식이 가능하긴 하다. 그럼에도 만들어주는 경우는 하위버전 호환을 위해서다.



**settings.py**는 프로젝트 설정을 해주는 파일.

- 시간대 설정, 데이터베이스 설정, 여러 경로 설정 등을 할 수 있게 해줌.
- 프로젝트의 전반적인 설정을 담당
- 참고 https://docs.djangoproject.com/en/3.2/ref/settings/



**urls.py**는 url들을 연결해준다.

- url을 보고 알맞은 페이지로 연결해 주는 역할
- view와 연결해 주는 역할



**wsgi.py** 위스키라고 읽음

- WebServer Gateway Interface, WSGI
- 웹 서버와 python 어플리케이션인 django가 소통하는데 필요한 일종의 프로토콜을 말한다.
- https://en.wikipedia.org/wiki/Web_Server_Gateway_Interface



**asgi.py**

- django 3.0 이상부터 지원하는 비동기 파일
- ASGI(Asynchronous Server Gateway Interface)





## 앱

프로젝트(project) vs 앱(App)

- 프로젝트는 웹 서비스 전체를 뜻함
- 앱은 프로젝트 내에서 기능을 나타내는 단위로 쓰인다.



app구조

- migrations
  - 데이터베이스의 변경 사항 히스토리 누적

- \_\_init\_\_.py
  - 파일이 있는 디렉토리를 파이썬 패키지로 인식하기 위해 필요
- admin.py
  - 앱을 djnago 관리자와 연동하기 위패 필요한 설정 파일
- apps.py
  - 앱에 대한 설정을 넣어두는 파일
  - https://docs.djangoproject.com/en/3.2/ref/applications/
- models.py
  - django app에서 사용할 데이터 모델 정의, 데이터베이스 연동과 관련된 파일
- teasts.py
  - 테스트 주도 개발, 프로젝트의 테스트 코드를 작성하는 곳
  - 테스트는 말 그대로 django 프로젝트의 모든 기능이 의도한 대로 잘 동작하는지 체크하는 것을 말함.
  - 작은 함수 하나를 체크하는 테스트부터 여러 함수의 상호작용이 있는 전박적인 큰 로직을 테스트하는 것까지 다양한 크기의 테스트가 있다.
  - 프로젝트를 모두 완성한 다음 테스트를 준비하는 것이 아니라 앱 별로 작은 단위의 자동화된 테스트를 미리 만들어서 프로젝트 전체에 대한 테스트가 효율적으로 이뤄질 수 있도록 작성하는 것이 좋다.
- views.py
  - django app의 메인 로직 처리와 관련된 파일
- url의 분기를 담당하는 것은 urls.py
- 데이터 베이스 구조 담당은 models.py
- 프로젝트와 앱의 연결은 settings.py에서 할 수 있음



**django의 핵심**

`models.py`와 `views.py`가 핵심



**필수**

새로운 앱을 만들었다면 장고에게 새로운 앱을 만들었다는 사실을 알려줘야 한다.

settings.py에 INSTALLED_APPS에 추가해주면 된다.



django 앱의 철학 : Reusable App (재사용성이 있는 앱)

잘 만들어둔 앱을 가져다가 쓸 수 있음.

어떤게 재사용성이 있다 할 수 있을까?

- 한 가지 앱은 한가지 기능을 하고, 그 기능을 잘 수행해야 한다.
- 장고 개발자는 프로젝트를 많은 앱으로 구성하는 것을 두려워하면 안 된다.
- 각각의 앱을 유연하게 작성해야 한다.
- 다른 사람에게 배포가 가능하도록 만들어야 한다.

(경험과 노하우가 생겨야 하는 것) (재사용성을 고려한건 장고 프로젝트가 아니라 장고 프로젝트 내 앱이다.)



## URL 작성

django 철학 : URL은 반드시 아름답게 작성되어야 한다.

```python
urlpatterns = [
	path('foods/', include('foods.urls'))
]
```

위에 path에서 'food/' 에는 뒤에 슬래쉬가 있다. 이를 트레일링 슬래쉬(trailing slash)라고 한다.

이렇게 쓰는 이유가 과거엔 '파일'과 '디렉토리'를 구분하는 것이 중요했기 때문이다. 
슬래쉬가 있는 경우는 '디렉토리'를, 없는 경우는 '파일'을 가리키도록 썼다. 
요즘날에는 URL로 구분하지않고 디비에서 저장, 불러오길 하니까 별로 구분하진 않는데, 개발하는 입장에서 통일된 형식을 따르기 위해 형식을 맞춰줬다.

장고는 기본적으로 트레일링 슬래시가 붙어 있지 않은 URL로 요청이 들어오면 먼저 해당 URL과 딱 맞는 URL 패턴이 있는지를 보고, 만약 없다면 슬래시를 붙인 URL로 다시 리다이렉션을 하도록 기본 설정이 되어 있다.

그래서 장고유저는 기본적으로 뒤에 /를 붙이자. 그러면 슬래쉬가 안붙은 URL로 요청이 들어오더라도 자동으로 슬래쉬가 붙은 URL로 연결된다.









## view에서 render란

```python
render(request, template_name, context=None, content_type=None, status=None, using=None)
```



render함수는 인자로 주어진 템플릿을 사전형(dict)인자인 context와 결합해서 렌더링을 거친 다음 HttpResponse 객체로 반환하는 함수다. 쉽게 말하면 인자로 넘겨주는 템플릿과 context 데이터를 합쳐서 HttpResponse 객체로 돌려주는 함수



필수는 `request`와 `template_name`이다.

- request : 데이터를 요청한 요청 객체를 넘겨줌. 이를 넘겨주는 이유는 요청에 대한 정보에 접근해서 user, session 등 여러 가지 기능을 구현하기 위해서임.
- template_name : 렌더링에 사용할 대상 템플릿을 명시



다음으로 선택 인자를 보면

- `context` 는 템플릿에 추가할 값들이 들어 있는 사전형 인자로 기본값은 아무것도 없는 None입니다.

- `content_type` 은 결과로 만들어 내는 문서의 유형을 말하며 기본값은 'text/html' 즉 HTML 웹 페이지입니다.

- `status` 는 상태 코드(Status Code) 값이며 기본값은 200(성공)입니다. 상태 코드는 클라이언트의 요청이 성공적으로 처리되었는지에 대한 정보를 주는 코드인데 뒤에서 자세하게 다루도록 하겠습니다.

- `using` 은 템플릿을 렌더하는 템플릿 엔진을 지정할 수 있는 인자입니다. 원하는 경우 다른 템플릿 엔진을 사용하여 템플릿을 렌더링할 수 있습니다.

   :) [render 공식문서 바로가기](https://docs.djangoproject.com/en/3.2/topics/http/shortcuts/#django.shortcuts.render)



## 장고 MVT 아키텍쳐

- Model
  - 데이터 구조 생성
  - 데이터베이스와 소통
- Template
  - 웹 사이트의 화면 구성 담당
  - 매번 바뀌는 동적인 화면을 구성(template language)
- View
  - 웹 사이트의 로직을 담당
  - Model과 Template 사이를 연결

![1](D:\codeit\수업필기\1.PNG)





## 아키텍처 패턴이란?

소프트웨어 내부에 존재하는 구조적인 패턴

대표적인 10가지 아키텍처 패턴

1. 계층화 패턴(Layered pattern)
2. 클라이언트-서버 패턴 (Client-server pattern)
3. 마스터-슬레이브 패턴 (Master-slave pattern)
4. 파이프-필터 패턴 (Pipe-filter pattern)
5. 브로커 패턴 (Broker pattern)
6. 피어 투 피어 패턴 (Peer-to-peer pattern)
7. 이벤트-버스 패턴 (Event-bus pattern)
8. MVC 패턴 (Model-view-controller pattern)
9. 블랙보드 패턴 (Blackboard- pattern)
10. 인터프리터 패턴 (Interpreter pattern)



- 클라이언트 - 서버 패턴
  - 클라이언트와 서버간의 요청과 응답 관계
- MVC 패턴
  - Model, View, Controller 세가지 파트로 나눠 개발
  - `모델`은 데이터를 저장, 보관
  - `뷰`는 사용자에게 보여지는 부분을 담당
  - `컨트롤러`는 사용자의 입력을 받아서 내부 로직을 처리
  - 분리하면 분업이 가능, 더 빠르고 완성도 있는 개발 가능
  - 유지 보수 용이
- MVC vs MVT
  - MVT는 MVC를 기반으로 만들어 졌다.
  - 바뀐점은 MVC의 뷰의 역할은 MVT의 Template가, MVC 컨트롤러의 역할은 MVT의 View가 맡는다.







## static file

정적 파일(static files) - CSS, JS, PNG, FONT 등등

웹 페이지를 랜더링(rendering)하는 과정에서 필요한 추가적인 파일



static을 쓰기 위해선 템플릿(html파일) 맨위에 `{% load static %}`을 써야 불러온다. 이를 탬플릿 태그라 한다. (template language)

- static에 있는 정적 파일을 현재 이 템플릿 파일에서 사용한다고 알려주는 것이다.





## 템플릿 언어

html 문서를 작성할 때 프로그래밍을 할 수 있게끔 해주는 언어다.

- 템플릿 변수 : 우리가 지정한 데이터로 변환
- 템플릿 태그 : 템플릿 작성에 로직을 사용
- 템플릿 필터 : 템플릿 변수를 특정 형식으로 변환
- 템플릿 주석 : 템플릿 언어의 주석처리를 담당



- 템플릿 변수
  - `{{ 변수명 }}` : 우리가 지정한 데이터로 변환
  - view에서 넘겨 받은 값으로 변환
  - `.`연산자를 이용해 템플릿 변수 내부 속성에 접근할 때 사용 = `{{ 변수명.속성 }}`
    - 변수 dict일 때 : .을 기준으로 key값 조회
    - 변수 객체일 때 : .을 기준으로 내부 속성값 조회 또는 함수 호출
    - 변수 리스트일 때 : .을 기준으로 index 조회
    - 자료형을 알고 .연산자를 써야 에러방지에 도움이 된다.



- 템플릿 필터
  - `{{ 변수명 | 필터 }}`
  - 템플릿 변수를 특정 형식으로 변환
  - 기본 필터로 60개정도 제공하며, 직접 사용자 지정을 만들어서 쓸수도 있음.
  - 필터 뒤에 인자를 필요로 하기도 함,  `:`로 구분 
    - default : `{{var | default:"coffee"}}` - 변수가 비었거나, False(불)이면 기본 반환 값 지정
    - capfirst : `{{var |capfirst}}` - 맨 첫글자를 대문자로 바꿔줌
    - random : `{{var | random }}` - 리스트형같은 경우 원소 하나를 랜덤으로 추출
    - ljust, rjust : `{{var | ljust:"10"}}` 주어진 길이 내에서 공백을 넣어 왼쪽 정렬, 오른쪽 정렬을 함
    - upper, lower
    - https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#ref-templates-builtins-filters



- 템플릿 태그
  - `{% 태그 %}`, `{% end태그 %}`
  - 템플릿 작성에 로직을 적용
  - 반복, 조건, 상속
  - for
    - `{% for obj in values %} ~ {% endfor %}`
    - `{% for food in foods %}     `
      `<li> {{ food.name }} </li> `
      `{% endfor %}`
    - `{% for food in foods reversed %}     `  - 역순 출력
      `<li> {{ food.name }} </li> `
      `{% endfor %}`
    - `{% for food in foods %}     ` - 빈 객체가 있으면 empty를 출력
      `<li> {{ food.name }} </li> `
      `{% empty %}    `
      `<li> There is no food. </li> `
      `{% endfor %}`
  - if
    - `{% if value1 %} ~ {% elif value2 %} ~ {% else %} ~ {% endif %}`
  - with
    - `{% with value1=value2 %} ~ {% endwith %}`
    - 복잡한 변수가 있을 때 '별명'을 붙이기 위해 사용합니다. with 구문 내에서는 value1을  value2 대신 사용할 수 있다.
  - https://docs.djangoproject.com/en/3.2/ref/templates/builtins/#ref-templates-builtins-tags



- 템플릿 주석
  - 주석 처리 지원, `{# 주석 #}`



- 사용자 정의 필터와 태그
  https://docs.djangoproject.com/en/3.2/howto/custom-template-tags/





## 템플릿 상속

여러 페이지에서 중복될 만한 템플릿 부분을 만들어놓고 상속받아 쓰면 편리하다.

공통부분을 `부모 파일`로 만들고, `자식 파일`에서는 달라지는 부분만 작성하면 된다.

상속은 `{% block %}`과 `{% extends %}`를 사용한다.



부모템플릿에서 자식 템플렛을 불러오는 곳에 `{% block food-container %}` `{% endblock food-container %}`을 만들어준다. (블록의 이름도 같이 작성)



자식템플릿 맨위에는 `{% extends './부모.html' %}`그리고 항상 맨 윗줄(첫줄)에 써줘야한다.

부모템플릿에 상속해주는 위치에 디폴트값을 넣을 수 있음. 자식템플릿에 상속위치에 값이 빠지면 부모템플릿에 디폴트 값이 출력됨













