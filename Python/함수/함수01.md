## 함수란?

여러개의 실행문을 하나로 묶은 모듈을 의미하며 특정한 명령을 수행하는 하나의 독립된 프로그램

함수는 `모듈화`를 기본으로 합니다. 



### 모듈화란?

특정 기능 부분을 실행 할 수 있는 블록으로 만들어 놓고 여러 실행 블록을 연결해서 프로그래밍 하는 것을 의미

파이썬 함수의 모듈화는 별도의 파일(`.py`)에 정의된 함수의 지정된 데이터나 class들의 모임을 저장한 것 중 모듈 안의 함수를 말합니다.

파이썬의 함수는 원하는 원형의 실행 구문을 만들어 모듈화(`*.py` -> `*pyc`(byte) -> `*.pvm` -> `output`)로 구현하고 호출하게 되면 실행되는 객체로 관리 됩니다.



참고 : pyc 파일에 대해서 <a href="https://jins-sw.tistory.com/25">세옹지인님 블로그글</a>



### 함수의 특징

1. 수행명령, 복잡한 연산등을 그룹으로 만들어서 새로운 함수로 선언
2. 함수명을 호출해서 명령실행, 디버깅, 오류 수정등을 수월하게 할 수 있게 해줍니다.
3. 반복 코드를 줄여 프로그램을 작게 만들 수 있게해줍니다.
4. 긴 코드를 나눠서 작성하게 되면 버그를 쉽게 수정할 수 있으며, 이를 조합해 전체적으로 동작하는 프로그램을 만들 수 있게 해줍니다.



### 함수의 종류

1. 라이브러리 함수

   - 표준함수 또는 내장함수라고 부르며 시스템에서 미리 작성해 놓은 함수
   - 삼각함수, 지수함수, 날짜함수, 파일함수, DB함수 등을 말합니다.
   - sys.path가 지정한 곳의 모듈

2. 사용자 정의함수

   - 사용자가 직접 만들어서 사용하는 함수 -> `.py` -> 전역패스 설치

3. built-in 함수

   - 파이썬 설치시 기본적으로 제공해주는 함수, `print()`, `type()` 함수 등.

   



### 함수 정의

```python
def 함수명(param1, param2, ... ):
    명령1
    명령2
    ...
    return ...
```

함수는 `def`로 정의하며 함수명에는 `파라미터(parameter)`를 써줍니다. 파라미터는 함수 안에서 처리할 때 사용할 값을 말합니다. 파라미터없이 정의할 수도 있으며 사용할 수도 있습니다.

`return`은 함수가 실행되고 결과를 반환하고자 할 때 쓰면됩니다. 반환할게 없다면 생략가능합니다. 이땐 None이 나옵니다.



### 함수 호출

함수는 호출되면 함수의 정의부(def 다음부터)로 이동해 함수의 모든 내용을 순차적으로 실행 한 후 함수가 종료되면 호출되었던 곳으로 돌아옵니다.

함수명() 또는 함수명(param...)로 호출하며 파라미터가 존재할 땐 정의한 파라미터의 타입에 맞게끔 파라미터를 전달해야 호출이 가능합니다.



### 함수 이름 컨벤션

일반적으로 함수명에는 `영소문자` + `_`를 사용합니다.

```python
def insert_coin():
	print('코인을 넣어주세요.')
    ...
```





### 파라미터와 아규먼트

우선 파라미터(parameter)와 인수(argument, 아규먼트)의 차이에 대해 살펴봅시다.
가인수(파라미터)와 실인수(아규먼트)라고도 부릅니다.

- 파라미터 : 함수를 선언할 때 호출하는 부분에서 보내주는 데이터를 받는 변수

- 아규먼트 : 함수를 호출할 때 함수에 보내주는 데이터

- 예를 들어서 다음의  `sum()` 함수를 정의한다면

  ```python
  def sum(num1, num2):
    return num1 + num2
  
  sum(1, 2)
  ```

  정의(선언)할 때 써주는 num1, num2는 파라미터고, 함수를 호출할 때 넣는 1, 2는 아규먼트입니다.





### 함수의 파라미터에 대해

함수를 선언할 때 파라미터를 쓸 수도, 안 쓸 수도 있는데 이러한 파라미터는 어떤 종류가 있을까요? 알아봅시다.



#### Positional Parameter 또는 Positional Argument

(위치 파라미터 또는 위치 아규먼트)

함수를 선언할 때 파라미터도 같이 선언하는데 이때 넣는 기본적인 파라미터입니다.

다음의 더하기 함수를 선언하고, 

```python
def sum(num1, num2):
	print(num1 + num2)
```

이를 호출 할 때는 기본적으로

```python
sum(1, 2)

> 3
```

이 때 sum함수에 넣는 1과 2는 함수를 선언할 때 넣은 파라미터와 같이 num1=1, num2=2를 의미합니다. 선언할 때 넣은 순서와 호출할 때 넣은 순서가 매칭이되는것이죠.



[주의사항]

정의한 파라미터보다 인수를 적거나, 많이 넣어주면 TypeError가 발생하게 됩니다.





#### Keyword Parameter 또는 Keyword Argument

(키워드 파라미터 또는 키워드 아규먼트)

위에서 정의한 sum함수에서 아규먼트를 1, 2로 주면 순서대로 호출되는 것을 볼 수 있었습니다. 이 때 아규먼트 이름을 줘서 호출을 해도됩니다. 이를 키워드 아규먼트라고 합니다.

키워드를 주게 되면 순서와 상관없이 인수를 전달할 수 있습니다.

```python
# 다음의 결과는 다 같습니다.
sum(1, 2)
sum(num1=1, num2=2)
sum(num2=2, num1=1)
```



[주의사항]

함수 선언시 사용한 파라미터 이름과 호출할 때 사용한 키워드의 이름이 다르면 TypeError 에러가 발생합니다.

```python
sum(num1=1, num3=3)
```

`TypeError : sum() got an unexpected keyword argument 'num3'`



[주의사항]

positional argument와 keyword argument를 조합해서 사용할 수 있습니다. 단 이땐 위치가 중요합니다.

일단 postional을 먼저 쓰고, 다음에 keyword를 써야합니다. 

```python
# 에러
sum(num1=1, 2)
```

`SyntaxError : positional argument follows keyword argument`

다음의 에러는 num1이 positional로 1이 들어갔는데 또 num1=1에서 1이 들어가니 발생하는 에러다.

```python
# 에러
sum(1, num1=1)
```

`TypeError : sum() got multiple values for argument 'num1'`





#### Default Parameter 또는 Dafault Argument

(디폴트 파라미터 또는 디폴트 아규먼트)

함수를 정의할 때 파라미터의 기본값을 지정할 수 있습니다. 만약 호출할 때 아규먼트가 전달되지 않을 때 기본적으로 정의한 값을 사용해서 함수가 실행됩니다.

```python
def sum(num1, num2=2):
	print(num1+num2)
```



아규먼트를 1개만 전달해도 디폴트로 정의된 2가 전달되어 함수가 정상적으로 실행됩니다.

```python
sum(1)

> 3
```



[주의사항]

함수 정의시 기본적인 위치 파라미터가 디폴트 파라미터보다 앞에 위치해야 합니다.

```python
# 이 경우 에러납니다.
sum(num1=1, num2):
    print(num1+num2)
```

`SyntaxError : non-default argument follows default argument`



[주의사항]

함수 정의시 디폴트값을 줄 때 주의할 점이 있습니다. 

```python
from random import randint

def sum(num1, num2=randint(1,10)):
    print(num1 + num2)
    
for i in range(10):
    sum(1)
```

이 경우 결과가 어떨까요? 함수를 호출 할 때마다 랜덤함수가 실행되서 다른 결과가 나올까요?

결과는 10번 모두 같은 값이 나옵니다.

왜이럴까요?

이는 함수가 정의될 때 파라미터를 실행하며 값을 계산해놉니다. 그렇기에 호출할 때마다 미리 계산해논 값을 계속해서 호출하는 것입니다. 이를 피하기 위해서는 None을 이용합시다.

```python
from random import randint

def sum(num1, num2=None):
    if num2 is None:
        num2 = randint(1,10)
    print(num1 + num2)
    
for i in range(10):
    sum(1)
```

이 경우 호출될 때마다 None이면 체크를 해서 num2에 randint값을 넣어서 실행됩니다.

